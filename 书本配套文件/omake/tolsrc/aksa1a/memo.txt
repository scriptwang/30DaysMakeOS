著作権者は川合秀実。ライセンスはKL-01。

使い方：DOSプロンプトで、
prompt>aska
とやると最低限度の説明が出る。

usage>aksa binfile ofs0 eip0 dd lines

  binfile：バイナリファイル  IA-32の実行コードが含まれていればどんなファイルでもよい。
  ofs0：逆ASKAしたいバイナリがファイルのどこに入っているか。
  eip0：そのバイナリの開始EIPの値。
  dd：0なら16bitモードで翻訳。1なら32bitモードで翻訳。
  lines：翻訳行数。

出力は標準出力に行うので、テキストファイルにしたければ適当にリダイレクトすればいいです。
mikan();というのがでたら、それはaksaが未完成で翻訳に失敗したという意味です。

---

例：helloc4.orgの逆ASKA

（註：helloc4.orgというのは、helloc4.binをbim2bin3で解凍したもの）
（prompt>bim2bin3 -restore in:helloc4.bin out:helloc4.org）

prompt>aksa helloc4.org 0 0 1 5
file-ofs   EIP
00000000 00000000 2E 8B 62 20       ESP = (int) [CS:EDX + 0x20];
00000004 00000004 8B FC             EDI = ESP;
00000006 00000006 EB 20             goto 0x00000028;
00000008 00000008 47                EDI++;
00000009 00000009 55                PUSH(EBP);

ここでgoto 0x28があったので、0x28から翻訳させてみる。

prompt>aksa helloc4.org 0x28 0x28 1 100
file-ofs   EIP
00000028 00000028 6A FF             PUSH(- 0x01);
0000002A 0000002A 0E                PUSH(CS);
0000002B 0000002B 68 59 02 00 00    PUSH(0x00000259);
00000030 00000030 2E FF 72 24       PUSH((int) [CS:EDX + 0x24]);
00000034 00000034 6A 82             PUSH(- 0x7E);
00000036 00000036 6A 04             PUSH(0x04);
00000038 00000038 8B DC             EBX = ESP;
0000003A 0000003A 57                PUSH(EDI);
0000003B 0000003B 9A 00 00 00 00 C7 CALLF(0x00C7, 0x00000000);
00000042 00000042 5C                POP(ESP);
00000043 00000043 E9 00 00 00 00    JMP(0x00000048);
00000048 00000048 55                PUSH(EBP);
00000049 00000049 89 E5             EBP = ESP;
0000004B 0000004B 56                PUSH(ESI);
0000004C 0000004C 53                PUSH(EBX);
0000004D 0000004D 6A 00             PUSH(0x00);
0000004F 0000004F 68 00 01 00 00    PUSH(0x00000100);
00000054 00000054 E8 FD 00 00 00    CALL(0x00000156);
00000059 00000059 89 04 24          (int) [SS:ESP] = EAX;
0000005C 0000005C 6A 04             PUSH(0x04);
0000005E 0000005E 6A 10             PUSH(0x10);
00000060 00000060 E8 DC 00 00 00    CALL(0x00000141);
00000065 00000065 6A 00             PUSH(0x00);
00000067 00000067 6A 30             PUSH(0x30);
00000069 00000069 68 88 00 00 00    PUSH(0x00000088);
0000006E 0000006E 68 00 02 00 00    PUSH(0x00000200);
00000073 00000073 68 80 00 00 00    PUSH(0x00000080);
00000078 00000078 E8 D9 00 00 00    CALL(0x00000156);
0000007D 0000007D 89 04 24          (int) [SS:ESP] = EAX;
00000080 00000080 6A 20             PUSH(0x20);
00000082 00000082 6A 10             PUSH(0x10);
00000084 00000084 E8 B8 00 00 00    CALL(0x00000141);
00000089 00000089 83 C4 2C          ESP += 0x2C;
0000008C 0000008C 89 C3             EBX = EAX;
0000008E 0000008E 6A 00             PUSH(0x00);
00000090 00000090 6A 00             PUSH(0x00);
00000092 00000092 68 C0 00 00 00    PUSH(0x000000C0);
00000097 00000097 50                PUSH(EAX);
00000098 00000098 6A 00             PUSH(0x00);
0000009A 0000009A 6A 00             PUSH(0x00);
0000009C 0000009C 6A 01             PUSH(0x01);
0000009E 0000009E 6A 07             PUSH(0x07);
000000A0 000000A0 6A 00             PUSH(0x00);
000000A2 000000A2 6A 78             PUSH(0x78);
000000A4 000000A4 E8 AD 00 00 00    CALL(0x00000156);
000000A9 000000A9 89 04 24          (int) [SS:ESP] = EAX;
000000AC 000000AC 68 00 10 00 00    PUSH(0x00001000);
000000B1 000000B1 6A 28             PUSH(0x28);
000000B3 000000B3 6A 14             PUSH(0x14);
000000B5 000000B5 E8 87 00 00 00    CALL(0x00000141);
000000BA 000000BA 83 C4 34          ESP += 0x34;
000000BD 000000BD 89 C6             ESI = EAX;
000000BF 000000BF 6A 00             PUSH(0x00);
000000C1 000000C1 6A 00             PUSH(0x00);
000000C3 000000C3 68 C0 00 00 00    PUSH(0x000000C0);
000000C8 000000C8 53                PUSH(EBX);
000000C9 000000C9 6A 10             PUSH(0x10);
000000CB 000000CB 6A 10             PUSH(0x10);
000000CD 000000CD 6A 01             PUSH(0x01);
000000CF 000000CF 6A 0C             PUSH(0x0C);
000000D1 000000D1 6A 00             PUSH(0x00);
000000D3 000000D3 68 A0 00 00 00    PUSH(0x000000A0);
000000D8 000000D8 E8 79 00 00 00    CALL(0x00000156);
000000DD 000000DD 89 04 24          (int) [SS:ESP] = EAX;
000000E0 000000E0 6A 00             PUSH(0x00);
000000E2 000000E2 6A 28             PUSH(0x28);
000000E4 000000E4 6A 14             PUSH(0x14);
000000E6 000000E6 E8 56 00 00 00    CALL(0x00000141);
000000EB 000000EB 83 C4 34          ESP += 0x34;
000000EE 000000EE 89 C3             EBX = EAX;
000000F0 000000F0 68 00 10 00 00    PUSH(0x00001000);
000000F5 000000F5 6A 00             PUSH(0x00);
000000F7 000000F7 6A 00             PUSH(0x00);
000000F9 000000F9 56                PUSH(ESI);
000000FA 000000FA 6A 00             PUSH(0x00);
000000FC 000000FC 6A 00             PUSH(0x00);
000000FE 000000FE 6A 00             PUSH(0x00);
00000100 00000100 E8 12 01 00 00    CALL(0x00000217);
00000105 00000105 68 08 10 00 00    PUSH(0x00001008);
0000010A 0000010A 6A 00             PUSH(0x00);
0000010C 0000010C 6A 00             PUSH(0x00);
0000010E 0000010E 53                PUSH(EBX);
0000010F 0000010F 6A 00             PUSH(0x00);
00000111 00000111 6A 00             PUSH(0x00);
00000113 00000113 6A 00             PUSH(0x00);
00000115 00000115 E8 FD 00 00 00    CALL(0x00000217);
0000011A 0000011A 83 C4 38          ESP += 0x38;
0000011D 0000011D 6A 00             PUSH(0x00);
0000011F 0000011F 6A 00             PUSH(0x00);
00000121 00000121 6A 00             PUSH(0x00);
00000123 00000123 6A 01             PUSH(0x01);
00000125 00000125 6A 18             PUSH(0x18);
00000127 00000127 E8 07 00 00 00    CALL(0x00000133);
0000012C 0000012C 8D 65 F8          LEA(ESP, (int) [SS:EBP - 0x08]);
0000012F 0000012F 5B                POP(EBX);
00000130 00000130 5E                POP(ESI);
00000131 00000131 5D                POP(EBP);
00000132 00000132 C3                return;
00000133 00000133 53                PUSH(EBX);
00000134 00000134 8D 5C 24 08       LEA(EBX, (int) [SS:ESP + 0x08]);

まだ続くようなので、さらに100行くらい見てみる。

prompt>aksa helloc4.org 0x134 0x134 1 101
file-ofs   EIP
00000134 00000134 8D 5C 24 08       LEA(EBX, (int) [SS:ESP + 0x08]);
00000138 00000138 9A 00 00 00 00 C7 CALLF(0x00C7, 0x00000000);
0000013F 0000013F 5B                POP(EBX);
00000140 00000140 C3                return;
00000141 00000141 53                PUSH(EBX);
00000142 00000142 8D 5C 24 0C       LEA(EBX, (int) [SS:ESP + 0x0C]);
00000146 00000146 9A 00 00 00 00 C7 CALLF(0x00C7, 0x00000000);
0000014D 0000014D 8B 44 24 08       EAX = (int) [SS:ESP + 0x08];
00000151 00000151 8B 04 04          EAX = (int) [SS:ESP + EAX * 1];
00000154 00000154 5B                POP(EBX);
00000155 00000155 C3                return;
00000156 00000156 56                PUSH(ESI);
00000157 00000157 53                PUSH(EBX);
00000158 00000158 52                PUSH(EDX);
00000159 00000159 51                PUSH(ECX);
0000015A 0000015A BE 1C 10 00 00    ESI = 0x0000101C;
0000015F 0000015F 8B 4C 24 14       ECX = (int) [SS:ESP + 0x14];
00000163 00000163 89 F0             EAX = ESI;
00000165 00000165 83 C1 0F          ECX += 0x0F;
00000168 00000168 83 E1 F8          ECX &= - 0x08;
0000016B 0000016B 3B 48 04          CMP(ECX, (int) [DS:EAX + 0x04]);
0000016E 0000016E 76 35             if ((unsigned) <= /* JBE */) goto 0x000001A5;
00000170 00000170 89 C2             EDX = EAX;
00000172 00000172 8B 00             EAX = (int) [DS:EAX];
00000174 00000174 39 F0             CMP(EAX, ESI);
00000176 00000176 75 F3             if (!= /* JNZ */) goto 0x0000016B;
00000178 00000178 31 C0             EAX ^= EAX;
0000017A 0000017A 3B 46 FC          CMP(EAX, (int) [DS:ESI - 0x04]);
0000017D 0000017D 75 41             if (!= /* JNZ */) goto 0x000001C0;
0000017F 0000017F 2E 8B 50 20       EDX = (int) [CS:EAX + 0x20];
00000183 00000183 2E 03 50 24       EDX += (int) [CS:EAX + 0x24];
00000187 00000187 83 C2 07          EDX += 0x07;
0000018A 0000018A 2E 8B 48 10       ECX = (int) [CS:EAX + 0x10];
0000018E 0000018E 83 E2 F8          EDX &= - 0x08;
00000191 00000191 89 4E FC          (int) [DS:ESI - 0x04] = ECX;
00000194 00000194 29 D1             ECX -= EDX;
00000196 00000196 89 4A 04          (int) [DS:EDX + 0x04] = ECX;
00000199 00000199 83 C2 08          EDX += 0x08;
0000019C 0000019C 52                PUSH(EDX);
0000019D 0000019D E8 23 00 00 00    CALL(0x000001C5);
000001A2 000001A2 58                POP(EAX);
000001A3 000001A3 EB BA             goto 0x0000015F;
000001A5 000001A5 8B 18             EBX = (int) [DS:EAX];
000001A7 000001A7 74 12             if (== /* JZ */) goto 0x000001BB;
000001A9 000001A9 8B 70 04          ESI = (int) [DS:EAX + 0x04];
000001AC 000001AC 8D 1C 08          LEA(EBX, (int) [DS:EAX + ECX * 1]);
000001AF 000001AF 89 48 04          (int) [DS:EAX + 0x04] = ECX;
000001B2 000001B2 29 CE             ESI -= ECX;
000001B4 000001B4 8B 08             ECX = (int) [DS:EAX];
000001B6 000001B6 89 73 04          (int) [DS:EBX + 0x04] = ESI;
000001B9 000001B9 89 0B             (int) [DS:EBX] = ECX;
000001BB 000001BB 89 1A             (int) [DS:EDX] = EBX;
000001BD 000001BD 83 C0 08          EAX += 0x08;
000001C0 000001C0 59                POP(ECX);
000001C1 000001C1 5A                POP(EDX);
000001C2 000001C2 5B                POP(EBX);
000001C3 000001C3 5E                POP(ESI);
000001C4 000001C4 C3                return;
000001C5 000001C5 60                PUSHAD();
000001C6 000001C6 8B 44 24 24       EAX = (int) [SS:ESP + 0x24];
000001CA 000001CA 83 E8 08          EAX -= 0x08;
000001CD 000001CD 72 46             if ((unsigned) < /* JC */) goto 0x00000215;
000001CF 000001CF BE 1C 10 00 00    ESI = 0x0000101C;
000001D4 000001D4 89 F2             EDX = ESI;
000001D6 000001D6 8B 1E             EBX = (int) [DS:ESI];
000001D8 000001D8 39 F3             CMP(EBX, ESI);
000001DA 000001DA 74 10             if (== /* JZ */) goto 0x000001EC;
000001DC 000001DC 39 D8             CMP(EAX, EBX);
000001DE 000001DE 72 0C             if ((unsigned) < /* JC */) goto 0x000001EC;
000001E0 000001E0 89 DA             EDX = EBX;
000001E2 000001E2 8B 1B             EBX = (int) [DS:EBX];
000001E4 000001E4 39 F3             CMP(EBX, ESI);
000001E6 000001E6 74 04             if (== /* JZ */) goto 0x000001EC;
000001E8 000001E8 39 D8             CMP(EAX, EBX);
000001EA 000001EA 77 F4             if ((unsigned) > /* JA */) goto 0x000001E0;
000001EC 000001EC 89 D1             ECX = EDX;
000001EE 000001EE 89 02             (int) [DS:EDX] = EAX;
000001F0 000001F0 03 4A 04          ECX += (int) [DS:EDX + 0x04];
000001F3 000001F3 89 18             (int) [DS:EAX] = EBX;
000001F5 000001F5 39 C8             CMP(EAX, ECX);
000001F7 000001F7 75 09             if (!= /* JNZ */) goto 0x00000202;
000001F9 000001F9 8B 48 04          ECX = (int) [DS:EAX + 0x04];
000001FC 000001FC 89 1A             (int) [DS:EDX] = EBX;
000001FE 000001FE 01 4A 04          (int) [DS:EDX + 0x04] += ECX;
00000201 00000201 92                XCHG(EAX, EDX);
00000202 00000202 89 C1             ECX = EAX;
00000204 00000204 03 48 04          ECX += (int) [DS:EAX + 0x04];
00000207 00000207 39 D9             CMP(ECX, EBX);
00000209 00000209 75 0A             if (!= /* JNZ */) goto 0x00000215;
0000020B 0000020B 8B 4B 04          ECX = (int) [DS:EBX + 0x04];
0000020E 0000020E 8B 1B             EBX = (int) [DS:EBX];
00000210 00000210 01 48 04          (int) [DS:EAX + 0x04] += ECX;
00000213 00000213 89 18             (int) [DS:EAX] = EBX;
00000215 00000215 61                POPAD();
00000216 00000216 C3                return;
00000217 00000217 55                PUSH(EBP);
00000218 00000218 53                PUSH(EBX);
00000219 00000219 50                PUSH(EAX);
0000021A 0000021A 89 E5             EBP = ESP;
0000021C 0000021C 8B 5D 28          EBX = (int) [SS:EBP + 0x28];
0000021F 0000021F 31 C0             EAX ^= EAX;

まだ続くようなので、さらに100行くらい見てみる。

G:\unbackuped\tools\aksa0a>aksa helloc4.org 0x21f 0x21f 1 101
file-ofs   EIP
0000021F 0000021F 31 C0             EAX ^= EAX;
00000221 00000221 3A 03             CMP(AL, (char) [DS:EBX]);
00000223 00000223 50                PUSH(EAX);
00000224 00000224 1E                PUSH(DS);
00000225 00000225 53                PUSH(EBX);
00000226 00000226 74 2B             if (== /* JZ */) goto 0x00000253;
00000228 00000228 43                EBX++;
00000229 00000229 3A 03             CMP(AL, (char) [DS:EBX]);
0000022B 0000022B 75 FB             if (!= /* JNZ */) goto 0x00000228;
0000022D 0000022D 2B 5D 28          EBX -= (int) [SS:EBP + 0x28];
00000230 00000230 53                PUSH(EBX);
00000231 00000231 50                PUSH(EAX);
00000232 00000232 8B 45 10          EAX = (int) [SS:EBP + 0x10];
00000235 00000235 FF 75 24          PUSH((int) [SS:EBP + 0x24]);
00000238 00000238 80 CC 50          AH |= 0x50;
0000023B 0000023B FF 75 20          PUSH((int) [SS:EBP + 0x20]);
0000023E 0000023E FF 75 1C          PUSH((int) [SS:EBP + 0x1C]);
00000241 00000241 FF 75 18          PUSH((int) [SS:EBP + 0x18]);
00000244 00000244 FF 75 14          PUSH((int) [SS:EBP + 0x14]);
00000247 00000247 50                PUSH(EAX);
00000248 00000248 6A 40             PUSH(0x40);
0000024A 0000024A 89 E3             EBX = ESP;
0000024C 0000024C 9A 00 00 00 00 C7 CALLF(0x00C7, 0x00000000);
00000253 00000253 89 EC             ESP = EBP;
00000255 00000255 58                POP(EAX);
00000256 00000256 5B                POP(EBX);
00000257 00000257 5D                POP(EBP);
00000258 00000258 C3                return;
00000259 00000259 04 80             AL += 0x80;
0000025B 0000025B 2D 0C AD 9F 16    EAX -= 0x169FAD0C;
00000260 00000260 F6                mikan();
00000261 00000261 33 40 08          EAX ^= (int) [DS:EAX + 0x08];
00000264 00000264 19 2C 20          SBB((int) [DS:EAX], EBP);
00000267 00000267 77 CD             if ((unsigned) > /* JA */) goto 0x00000236;
00000269 00000269 CA                mikan();
0000026A 0000026A 6B                mikan();
0000026B 0000026B 20 07             (char) [DS:EDI] &= AL;
0000026D 0000026D AD                LODSD();
0000026E 0000026E 1C 10             SBB(AL, 0x10);

ここで100行に満たないうちに打ち切られたのは、対象ファイルが尽きたからである。

ここまでの解析で、有効なプログラムは
0x0000-0x0007  スタートアップ1
0x0008-0x0027  おそらく何らかのデータ
0x0028-0x0047  スタートアップ2
0x0048-0x0132  おそらくOsaskMain
0x0133-0x0140  おそらくlib_execcmd0
0x0141-0x0155  おそらくlib_execcmd1
0x0156-0x01c4  おそらくmalloc
0x01c5-0x0216  おそらくmallocの下請け
0x0217-0x0258  おそらくlib_putstring_ASCII
0x0259-        おそらく何らかのデータ
ということがわかる。

.exeを解析する場合は、メモリ上にロードされるときのイメージを作るツールを別途用意して、
そのイメージをaksaで解析するのがいいだろう。
