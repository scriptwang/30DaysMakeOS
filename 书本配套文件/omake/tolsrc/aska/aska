---------------------------------------------------------------------
                  C言語型アセンブラ"ASKA" Ver1.0β18
---------------------------------------------------------------------
制作日：2001/10/01
制作者：shoe16(shoe16@wizard.elec.waseda.ac.jp)
総指揮：川合堂
修正日：2001/12/06
修正者：RisaPapa(ringring@zb4.so-net.ne.jp)

１．ASKAとは

　従来型アセンブラの記述を、１文＝１命令を守りつつC言語になるべく近づ
けようという構想の下に生まれたものがASKAです。
　従来、アセンブラではif文やloop文などでは不必要にラベルが増えてしま
い管理が非常に大変でした。また構造体が貧弱なため、きちんとしたデータ
型を見通しよくサポートするのが非常に困難でした。さらに、アセンブラは
フリースタイル型の言語ではないために１行に１命令となり行数が非常に多
くなってプログラムの見通しが悪くなっていました。
　このような問題に対処するべく、開発されたのがASKAというわけです。



２．ASKAの使い方

　DOSのコマンドプロンプト上から

	ASKA 入力ファイル名 出力ファイル名

とすると入力ファイルをコンパイルして386ASM形式の出力ファイルを生成し
ます。出力ファイルを省略こともできます。その場合、入力ファイル名が
"sample.ask"ならば出力ファイル名は"sample.asm"になります。

例：
	C:\ASKA\WORK\>ASKA sample.ask sample.asm
	C:\ASKA\WORK\>ASKA sample.ask


重要：コマンドプロンプトのプロパティ（command.comのショートカットの
　　　プロパティ）のメモリ−プロテクトモード(DPMI)メモリの合計を自動
　　　でなくて1024などにしてください。自動のままだと動きません。


３．ASKAの特徴的な機能

　ASKAでは、

・if〜else〜、loop〜break、for、while、do〜while、continueが使えます。
・char、short、long、byte、word、dwordで変数宣言が出来ます。
・関数内でstaticキーワードを使うことで静的な変数が宣言できます。
・関数は戻り値、引数なしのvoid funcname();で宣言が出来ます。
・式文には=、+=、-=、*=、/=、&=、|=、^=、<<=、>>=、=-、=~、が使えます。
・比較式には==、!=、<、<=、>、>=、が使えます。
・構造体による型定義が使えます。
・ポインタや配列も使えます。
・segmentによるセグメント定義もきちんと出来ます。
・現バージョンのASKAで補いきれていない386ASM本来のニーモニック命令も
　「asmkeyword(list, ...);」でサポート。
・上記で出来ない".386p"などはasmout(".386p");でサポート。
・エイリアスというレジスタを変数に割り当てて使う事が出来ます。
・ローカル変数が定義できます。

　逆に、ASKAでは、

・ラベルの前方参照が出来ません。
・関数に引数を持たせることが出来ません。



４．簡易言語仕様

・インクルード
	include "ファイル名"
とすることでファイルを読み込むことが出来ます。
　また、includeの代わりに#includeでも同じ動作をします。


・コメント
	// コメント文
とする事で//以降、改行が現れるまでの文がコメントアウトされます。これ
らのコメント文は切り捨てられます。
　また、C言語っぽく/* 〜 */もサポートしました。ただ、ネストが効くように
組んであるので注意が必要です。


・式のパラメータ
　式のパラメータはレジスタ(r)、メモリ参照(m)、即値(i)の３種類がありま
す。それぞれ、
	r:EAX, CX, DS, CR0
	m:data, data[0], [EAX], [DS:EAX+EBX*2+&data+~3], *(EAX+1)
	i:0xffff,-1,100,0b0011,&DATA,sizeof(TYPE),
などのようにかけます。また、変数やメモリ参照のデータ型を一時的に変え
たり定義する場合にはキャストを使うことが出来ます。

※ここにキャスト関係、即値演算関係、[]内記述方式関係を書く


・式文
　式文は
	rm  = rmi;	→	MOV	rm,rmi
			→	MOVSX or MOVZX	(サイズが違うとき)
	r   =   0;	→	XOR	r ,r
	rm += rmi;	→	ADD	rm,rmi
	rm +=   1;	→	INC	rm
	rm -= rmi;	→	SUB	rm,rmi
	rm -=   1;	→	DEC	rm
	rm *=   1;	→	最適化により省略
	reg*=   2;	→	ADD	reg,reg
	rm *=   2;	→	SHL	rm,2
	r32*=   3;	→	LEA	r32,[r32 * 2 + r32]
	rm *=   4;	→	SHL	rm,2
	r32*=   5;	→	LEA	r32,[r32 * 4 + r32]
	rm *=   8;	→	SHL	rm,3
	r32*=   9;	→	LEA	r32,[r32 * 8 + r32]
	rm *=   1;	→	最適化により省略
	rm *=   2;	→	SAR	rm,1	(unsignedの時はSHR)
	rm *=   4;	→	SAR	rm,2	(unsignedの時はSHR)
	rm *=   8;	→	SAR	rm,4	(unsignedの時はSHR)
	rm &= rmi;	→	AND	rm,rmi
	rm |= rmi;	→	OR	rm,rmi
	rm ^= rmi;	→	XOR	rm,rmi
	rm<<= rmi;	→	SAL	rm,rmi	(unsignedの時はSHL)
	reg<<=  1;	→	ADD	reg,reg
	rm>>= rmi;	→	SAR	rm,rmi	(unsignedの時はSHR)
	rm =- rmi;	→	NEG	rm
	rm =~ rmi;	→	NOT	rm
	rm++;		→	INC	rm
	rm--;		→	DEC	rm
のようになります。インクリメントとデクリメント以外は左に１パラメータ、
右に１パラメータです。ただし、=-と=~は左と右のパラメータがまったく同
じでなければなりません。
＃現バージョンではチェックは行われていませんが・・・

特殊な場合としてfar*で宣言されたラベルおよびエイリアスは、+=,-=,++,--
に限ってoffsetキャストをつけなくてもデフォルトでオフセットに演算が施
されます。また、左辺と右辺で同一のセグメントレジスタを指定したエイリ
アスの場合は、オフセットのみが代入されます。さらに、左辺がエイリアス
で右辺がメモリの時は例のようにL(segreg)命令を使ってデコードされます。

例：
	int*	a == DS:EAX;
	int*	b;
	a = b			→	LDS	EAX,b


・比較式とif〜else文
　比較式はif()文の中で使われていますが、演算子が違うこと以外は式文と
まったく同じです。「==、!=、<、<=、>、>=」が使えます。
　ただ、大小の比較の時に符号のありなしが重要になってくるので、変数の
型等がない場合にはキャスト(unsigned)か(signed)をつけて明示的に符号の
ありなしを宣言する必要があります。このとき、必ず左のパラメータの前に
つけるようにしてください。それ以外はエラーとなります。

例：
						cmp	eax,0
	if((unsigned)EAX > 0){			jbe	#LL0000
		
						jmp	#LL0001
	}else{				#LL0000:
		
	}				#LL0001:

　ただしif〜gotoとif〜breakおよびif〜continueはラベルが最適化されてジ
ャンプが２回おこなわれることはありません。

例：
	if((unsigned)EAX > 0)			cmp	eax,0
		goto label;			ja	#label

　また、比較する際に

例：
	if((unsigned)>){			jbe	#LL0000
		
						jmp	#LL0001
	}else{				#LL0000:
		
	}				#LL0001:

のように記述することもできます。これにより比較は行われずにフラグによ
るジャンプのみを生成します。

以下、参考として、比較文で使用できる形式を書きます。

	a==b, a!=b, a<b, a<=b, a>b, a>=b	：cmp付き
	==, !=, <, <=, >, >=			：cmp無し
	==0, !=0				：cmp無し別バージョン
	a, !a					：a!=0, a==0の別の書き方


・loop文
　loop文は永久ループを作り出します。永久ループから抜けるためにはbreak
文を使う必要があります。

例：
	loop{				#LL0000:
		
						jmp	#LL0000
	}				#LL0001:


・break文
　break文はloop文から抜けるためにあります。ネストしたloopを一気に抜け
るためにbreakのあとに数字をつけることが出来ます。この数字は一気にloop
文を抜ける数を表します。つまり、数字をつけないただのbreak;文は'1'が省
略されていることになります。

例：
	break;
	break 2;


・for文
　同様に、for文は以下のようになります。

例：
	for(ECX=0; ECX<10; ECX++){		xor	ecx,ecx
					#LL0000:
						cmp	ecx,10
						jge	#LL0001
		
						inc	ecx
						jmp	#LL0000
	}				#LL0001:

＃例文ではmov r,0  →  xor r,rの最適化をしています


・while文

　同様に、while文は以下のようになります。

例：
	while(EAX == 0){		#LL0000:
						test	eax,eax
						jne	#LL0001
		
						jmp	#LL0000
	}				#LL0001:

＃例文ではcmp r,0  →  test r,rの最適化をしています


・do〜while文

　同様に、do〜while文は以下のようになります。

例：
	do{				#LL0000:
		
						test	eax,eax
						je	#LL0000
	}while(EAX == 0);		#LL0001:

＃例文ではcmp r,0  →  test r,rの最適化をしています


・変数定義
　変数定義は

例：
	char		a;	符号ありで1バイト
	short		b;	符号ありで2バイト
	long		c;	符号ありで4バイト
	byte		d;	符号なしで1バイト
	word		e;	符号なしで2バイト
	dword		f;	符号なしで4バイト
	long*		g;	デフォルトではfarポインタ
	long near *	h;	nearキーワードをつければnearポインタ
	dword		i[12];	dword型の配列12バイト
	int		j;	符号ありで4バイト
	unsigned int	k;	unsignedにより符号なしで4バイト

のようになります。ここで注意すべきは配列でしょう。通常のC言語では配列
は「型の要素を何個確保するか」でしたが、ASKAでは単純に「何バイト確保
するか」という意味になります。つまり、例文の意味は「dword型の配列を３
要素確保する」という意味になります。
　また、これがグローバルな定義ならば初期化が許されます。ただし、現在
では構造体を初期化することは出来ません。配列の場合は""を使った文字列
のみ可能です。

例：
	long	c = 1;

　また、ローカルな定義だったら、現在では初期化は許されません。
ローカル変数を使う場合、かなり制約があるので注意してください。

例：（川合社長より）

	void function()
	{
	    PUSH(EBP);  /* これは、組み込み関数 */
	    ESP -= local;  /* localは、ASKAの特別な変数 */
	    EBP = ESP;
	
	    int a, b;
	    a = 3;
	    b = ECX;
	
	    ESP = EBP + local;
	    POP(EBP);
	    return;
	}

このように、スタックの管理をしっかりしないと暴走します。
ソース中のlocalはシステム変数で、この関数で使われているローカル変数の
総バイト数を表します。また、ローカル変数をデフォルトのSS:EBPに割り付けたく
ない場合は、

例：
	default(local == SS:EBP - local);

の構文で変更することが出来ます。ちなみに、上記の方法はENTER,LEAVEを使う時の
書き方です。

※default == の式や、&&は廃止されました。


　ローカルな定義のエイリアスによるレジスタへの割付は、

例：
	long	c == EAX;

　こうすることで、cをアクセスするとEAXをアクセスするのと同じ効果が得
られます。一見あまり意味が内容に思えますが、利点として一つはレジスタ
に名前を与える事が出来るために用途がはっきりするのと、もう一つは、

例：
	struct	Point{
		long	x;
		long	y;
	};

	Point*	p == DS:EAX;

のように構造体を定義してそのポインタのエイリアスを作ることで、

例：
	p->x = 7;			mov	DS:[EAX],7
	p->y = 9;			mov	DS:[EAX+4],9

のように構造体にアクセスすることが出来るようになります。
　これは、通常変数のポインタは参照できないという弱点を補うのに十分な
拡張であると考えます。また、

例：
	void	[2];

で手動アラインを行うことが出来ます。

さらに、staticキーワードを使うことで、関数内に静的変数を作り出す事が
出来るようになりました。

例：
	static long DATA::staticdata;

例の通り、必ず割り付けるセグメント名を明示してください。

また、自動static変数とも言うべき、文字列自動割付がサポートされました。

例：
	EAX = DATA::"string\n";

このように、関数中に文字列を割り付けることが出来ます。


・構造体定義
　構造体はC言語と言うよりは、C++言語に近いかもしれません。もちろん関
数を中に含めたりは出来ませんが、typedefでいちいち定義したりしなくても
良いところがC言語の構造体に比べて便利です。書式はエイリアスの所を参照
してください。


・セグメント定義
　関数や変数をどのセグメントに割り付けるかはしっかり定義しなければな
りません。

例：
	segment DATA(DWORD, PRIVATE, USE32, RW, 'DATA');

　ここで、()内のパラメータは順序に関係ありません。好きなように書いて
ください。また、グローバル変数はこのsegment命令内でしか書くことが出来
ません。

例：
	segment DATA(DWORD, PRIVATE, USE32, RW, 'DATA'){
		long	a = 1;
		dword	b;
	}


・関数定義
　関数は、まずそれを割り付けるセグメントが無ければなりません。上記の
segment命令によってセグメントを作成してください。

例：
	segment CODE(DWORD, PRIVATE, USE32, ER, 'CODE');

そのあと、

例：
	void CODE::func(){
		
	}
		または
	void CODE::func(void){
		
	}

で関数を宣言することが出来ます。この関数の中にプログラムを書くことに
なります。このとき、C言語のように自動でreturnを付けたりはしないので
注意してください。
　また、C言語と同じく、特別な関数としてmain()があります。これがプロ
グラム内にあった場合、「end main」がアセンブラへの展開時に追加されま
す。つまり、mainがエントリポイントになるわけです。

他に関数のプロトタイプ宣言もサポートしてますので、

例：
	void CODE::func();
		または
	void CODE::func(void);

と書くこともできます。

・ラベル
　ラベルは

例：
label1:
@label2:
#label3:

void	main(){
label4:
@label5:
#label6:
}

の書き方があります。ここで@はグローバルスコープを意味し、#はローカルスコープを
意味します。なにもつけないとデフォルトの意味になります。
しかしグローバルスコープでローカルラベルは定義できないので、label3はエラーに
なります。

注意していただきたいのは、このラベルの使い方です。後方参照する場合には自動的に
グローバルかローカルか判断してくれるのでよいのですが、前方参照の場合には
自動的に判別できず、ローカルスコープにしてしまいます。


５．サンプル

　申し訳ありません、まだ出来てません（汗

６．免責
　これはフリーソフトです。このソフトを使ってなんらかの障害を起こしたとしても
当方は責任をいっさい負いません。
　また、これは当分の間転載禁止です。
　このソフトにはやねうらおさんが作成した
	yaneurao GAME SDK for Windows95/98/NT/2000 version 1.00α4
のスクリプト部分の骨格部分、および字句解析部を（ソースフリーであるため）
ほぼそのまま使わせていただきました。

※ソースフリーとはいえ規格外の使い方であるため、やねうらおさんの許可を
　まだ得ていない現状はとりあえず社内公開のみ。

また、やねうらおさんのWebページは
	http://www.sun-inet.or.jp/~yaneurao/
です。
